/**
 * File generated by the ThingML IDE
 * /!\Do not edit this file/!\
 * In case of a bug in the generated code,
 * please submit an issue on our GitHub
 **/

package org.thingml.generated.blink.fourLEDS
import org.sintef.smac._
// Definition of Enumeration  PinMode
object PinMode_ENUM extends Enumeration {
  type PinMode_ENUM = Byte
  val PINMODE_INPUT : Byte = 0
  val PINMODE_OUTPUT : Byte = 1
}
// Definition of Enumeration  DigitalState
object DigitalState_ENUM extends Enumeration {
  type DigitalState_ENUM = Byte
  val DIGITALSTATE_LOW : Byte = 0
  val DIGITALSTATE_HIGH : Byte = 1
}
// Definition of Enumeration  DigitalPin
object DigitalPin_ENUM extends Enumeration {
  type DigitalPin_ENUM = Byte
  val DIGITALPIN_PIN_0 : Byte = 0
  val DIGITALPIN_PIN_1 : Byte = 1
  val DIGITALPIN_PIN_2 : Byte = 2
  val DIGITALPIN_PIN_3 : Byte = 3
  val DIGITALPIN_PIN_4 : Byte = 4
  val DIGITALPIN_PIN_5 : Byte = 5
  val DIGITALPIN_PIN_6 : Byte = 6
  val DIGITALPIN_PIN_7 : Byte = 7
  val DIGITALPIN_PIN_8 : Byte = 8
  val DIGITALPIN_PIN_9 : Byte = 9
  val DIGITALPIN_PIN_10 : Byte = 10
  val DIGITALPIN_PIN_11 : Byte = 11
  val DIGITALPIN_PIN_12 : Byte = 12
  val DIGITALPIN_PIN_13 : Byte = 13
  val DIGITALPIN_A_0 : Byte = 14
  val DIGITALPIN_A_1 : Byte = 15
  val DIGITALPIN_A_2 : Byte = 16
  val DIGITALPIN_A_3 : Byte = 17
  val DIGITALPIN_A_4 : Byte = 18
  val DIGITALPIN_A_5 : Byte = 19
}
// Definition of Enumeration  PWMPin
object PWMPin_ENUM extends Enumeration {
  type PWMPin_ENUM = Byte
  val PWMPIN_PWM_PIN_3 : Byte = 3
  val PWMPIN_PWM_PIN_5 : Byte = 5
  val PWMPIN_PWM_PIN_6 : Byte = 6
  val PWMPIN_PWM_PIN_9 : Byte = 9
  val PWMPIN_PWM_PIN_10 : Byte = 10
  val PWMPIN_PWM_PIN_11 : Byte = 11
}
// Definition of Enumeration  AnalogPin
object AnalogPin_ENUM extends Enumeration {
  type AnalogPin_ENUM = Byte
  val ANALOGPIN_A_0 : Byte = 14
  val ANALOGPIN_A_1 : Byte = 15
  val ANALOGPIN_A_2 : Byte = 16
  val ANALOGPIN_A_3 : Byte = 17
  val ANALOGPIN_A_4 : Byte = 18
  val ANALOGPIN_A_5 : Byte = 19
}
// Definition of Enumeration  AnalogReference
object AnalogReference_ENUM extends Enumeration {
  type AnalogReference_ENUM = Byte
  val ANALOGREFERENCE_DEFAULT : Byte = 1
  val ANALOGREFERENCE_INTERNAL : Byte = 3
  val ANALOGREFERENCE_EXTERNAL : Byte = 0
}
// Definition of Enumeration  InterruptPin
object InterruptPin_ENUM extends Enumeration {
  type InterruptPin_ENUM = Byte
  val INTERRUPTPIN_PIN_2_INT0 : Byte = 0
  val INTERRUPTPIN_PIN_3_INT1 : Byte = 1
}
// Definition of Enumeration  InterruptTrigger
object InterruptTrigger_ENUM extends Enumeration {
  type InterruptTrigger_ENUM = Byte
  val INTERRUPTTRIGGER_CHANGE : Byte = 1
  val INTERRUPTTRIGGER_RISING : Byte = 3
  val INTERRUPTTRIGGER_FALLING : Byte = 2
  val INTERRUPTTRIGGER_LOW : Byte = 0
}
object Led_toggle{ def getName = "led_toggle" }
case class Led_toggle(override val name : String = Led_toggle.getName) extends Event(name)
object NoTone{ def getName = "noTone" }
case class NoTone(pin : Byte, override val name : String = NoTone.getName) extends Event(name)
object Led_on{ def getName = "led_on" }
case class Led_on(override val name : String = Led_on.getName) extends Event(name)
object TestOut{ def getName = "testOut" }
case class TestOut(c : Char, override val name : String = TestOut.getName) extends Event(name)
object Led_off{ def getName = "led_off" }
case class Led_off(override val name : String = Led_off.getName) extends Event(name)
object TestFailure{ def getName = "testFailure" }
case class TestFailure(override val name : String = TestFailure.getName) extends Event(name)
object Eeprom_sync_write{ def getName = "eeprom_sync_write" }
case class Eeprom_sync_write(address : Int, value : Short, override val name : String = Eeprom_sync_write.getName) extends Event(name)
object InterruptNotification{ def getName = "interruptNotification" }
case class InterruptNotification(interrupt : Byte, override val name : String = InterruptNotification.getName) extends Event(name)
object PinMode{ def getName = "pinMode" }
case class PinMode(pin : Byte, mode : Byte, override val name : String = PinMode.getName) extends Event(name)
object Eeprom_value{ def getName = "eeprom_value" }
case class Eeprom_value(value : Short, override val name : String = Eeprom_value.getName) extends Event(name)
object Pong{ def getName = "pong" }
case class Pong(override val name : String = Pong.getName) extends Event(name)
object Ping{ def getName = "ping" }
case class Ping(override val name : String = Ping.getName) extends Event(name)
object Timer_timeout{ def getName = "timer_timeout" }
case class Timer_timeout(override val name : String = Timer_timeout.getName) extends Event(name)
object Timer_start{ def getName = "timer_start" }
case class Timer_start(delay : Int, override val name : String = Timer_start.getName) extends Event(name)
object DigitalReadResult{ def getName = "digitalReadResult" }
case class DigitalReadResult(value : Byte, override val name : String = DigitalReadResult.getName) extends Event(name)
object Timer_cancel{ def getName = "timer_cancel" }
case class Timer_cancel(override val name : String = Timer_cancel.getName) extends Event(name)
object AnalogReference{ def getName = "analogReference" }
case class AnalogReference(`type` : Byte, override val name : String = AnalogReference.getName) extends Event(name)
object DetachInterrupt{ def getName = "detachInterrupt" }
case class DetachInterrupt(interrupt : Byte, override val name : String = DetachInterrupt.getName) extends Event(name)
object AnalogWrite{ def getName = "analogWrite" }
case class AnalogWrite(pin : Byte, value : Short, override val name : String = AnalogWrite.getName) extends Event(name)
object AttachInterrupt{ def getName = "attachInterrupt" }
case class AttachInterrupt(interrupt : Byte, mode : Byte, override val name : String = AttachInterrupt.getName) extends Event(name)
object AnalogReadResult{ def getName = "analogReadResult" }
case class AnalogReadResult(value : Int, override val name : String = AnalogReadResult.getName) extends Event(name)
object Tone{ def getName = "tone" }
case class Tone(pin : Byte, frequency : Int, duration : Int, override val name : String = Tone.getName) extends Event(name)
object DigitalWrite{ def getName = "digitalWrite" }
case class DigitalWrite(pin : Byte, value : Byte, override val name : String = DigitalWrite.getName) extends Event(name)
object DigitalRead{ def getName = "digitalRead" }
case class DigitalRead(pin : Byte, override val name : String = DigitalRead.getName) extends Event(name)
object Eeprom_write_ack{ def getName = "eeprom_write_ack" }
case class Eeprom_write_ack(override val name : String = Eeprom_write_ack.getName) extends Event(name)
object Poll{ def getName = "poll" }
case class Poll(override val name : String = Poll.getName) extends Event(name)
object TestIn{ def getName = "testIn" }
case class TestIn(c : Char, override val name : String = TestIn.getName) extends Event(name)
object Eeprom_write{ def getName = "eeprom_write" }
case class Eeprom_write(address : Int, value : Short, override val name : String = Eeprom_write.getName) extends Event(name)
object AnalogRead{ def getName = "analogRead" }
case class AnalogRead(pin : Byte, override val name : String = AnalogRead.getName) extends Event(name)
object Eeprom_read{ def getName = "eeprom_read" }
case class Eeprom_read(address : Int, override val name : String = Eeprom_read.getName) extends Event(name)
object Setup{ def getName = "setup" }
case class Setup(override val name : String = Setup.getName) extends Event(name)

/**
 * Definitions for type : Arduino
 **/
class Arduino extends Component {

  new Port("DigitalIO", List(PinMode.getName, DigitalRead.getName, DigitalWrite.getName), List(DigitalReadResult.getName), this).start
  new Port("AnalogIO", List(AnalogReference.getName, AnalogRead.getName, AnalogWrite.getName), List(AnalogReadResult.getName), this).start
  new Port("AdvancedIO", List(Tone.getName, NoTone.getName), List(), this).start
  new Port("Ping", List(Ping.getName), List(Pong.getName), this).start
  new Port("Interrupts", List(AttachInterrupt.getName, DetachInterrupt.getName), List(InterruptNotification.getName), this).start
  new Port("EEPROM", List(Eeprom_read.getName, Eeprom_sync_write.getName, Eeprom_write.getName), List(Eeprom_value.getName, Eeprom_write_ack.getName), this).start
  this.behavior ++= List(new ArduinoStdlibImplStateMachine(false, this).getBehavior)
  case class ArduinoStdlibImplStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
      println(this + ".onEntry")
//No entry action defined for this state
    }

    override def onExit() = {
      println(this + ".onExit")
//No exit action defined for this state
    }

//create sub-states
    val RunningArduino_state = new State(RunningArduinoState(), root)
    parent.addSubState(RunningArduino_state)
    val t_self_195280012 = new InternalTransition(RunningArduino_state, new InternalTransition195280012(), root)
    t_self_195280012.initEvent(PinMode.getName)
    RunningArduino_state.addInternalTransition(t_self_195280012)
    val t_self_1632961370 = new InternalTransition(RunningArduino_state, new InternalTransition1632961370(), root)
    t_self_1632961370.initEvent(DigitalWrite.getName)
    RunningArduino_state.addInternalTransition(t_self_1632961370)
    val t_self_21845470 = new InternalTransition(RunningArduino_state, new InternalTransition21845470(), root)
    t_self_21845470.initEvent(DigitalRead.getName)
    RunningArduino_state.addInternalTransition(t_self_21845470)
    val t_self_1731742314 = new InternalTransition(RunningArduino_state, new InternalTransition1731742314(), root)
    t_self_1731742314.initEvent(AnalogReference.getName)
    RunningArduino_state.addInternalTransition(t_self_1731742314)
    val t_self_1579211959 = new InternalTransition(RunningArduino_state, new InternalTransition1579211959(), root)
    t_self_1579211959.initEvent(AnalogRead.getName)
    RunningArduino_state.addInternalTransition(t_self_1579211959)
    val t_self_905375489 = new InternalTransition(RunningArduino_state, new InternalTransition905375489(), root)
    t_self_905375489.initEvent(AnalogWrite.getName)
    RunningArduino_state.addInternalTransition(t_self_905375489)
    val t_self_1242399156 = new InternalTransition(RunningArduino_state, new InternalTransition1242399156(), root)
    t_self_1242399156.initEvent(Tone.getName)
    RunningArduino_state.addInternalTransition(t_self_1242399156)
    val t_self_703270096 = new InternalTransition(RunningArduino_state, new InternalTransition703270096(), root)
    t_self_703270096.initEvent(NoTone.getName)
    RunningArduino_state.addInternalTransition(t_self_703270096)
    case class RunningArduinoState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
//No entry action defined for this state
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    parent.setInitial(RunningArduino_state)

//create transitions among sub-states
    case class InternalTransition195280012 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        /*println("pinMode(getEvent(PinMode.getName).get.asInstanceOf[PinMode].pin, getEvent(PinMode.getName).get.asInstanceOf[PinMode].mode");*/
      }

    }
    case class InternalTransition1632961370 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        /*println("digitalWrite(getEvent(DigitalWrite.getName).get.asInstanceOf[DigitalWrite].pin, getEvent(DigitalWrite.getName).get.asInstanceOf[DigitalWrite].value");*/
      }

    }
    case class InternalTransition21845470 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        handler.root.getPort("DigitalIO") match{
          case Some(p) => p.send(new DigitalReadResult(0))
          case None => println("Warning: no port DigitalIO You may consider revising your ThingML model.")
        }
      }

    }
    case class InternalTransition1731742314 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        /*println("analogReference(getEvent(AnalogReference.getName).get.asInstanceOf[AnalogReference].`type`");*/
      }

    }
    case class InternalTransition1579211959 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        handler.root.getPort("AnalogIO") match{
          case Some(p) => p.send(new AnalogReadResult(0))
          case None => println("Warning: no port AnalogIO You may consider revising your ThingML model.")
        }
      }

    }
    case class InternalTransition905375489 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        /*println("analogWrite(getEvent(AnalogWrite.getName).get.asInstanceOf[AnalogWrite].pin, getEvent(AnalogWrite.getName).get.asInstanceOf[AnalogWrite].value");*/
      }

    }
    case class InternalTransition1242399156 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        /*println("tone(getEvent(Tone.getName).get.asInstanceOf[Tone].pin, getEvent(Tone.getName).get.asInstanceOf[Tone].frequency, getEvent(Tone.getName).get.asInstanceOf[Tone].duration");*/
      }

    }
    case class InternalTransition703270096 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        /*println("noTone(getEvent(NoTone.getName).get.asInstanceOf[NoTone].pin");*/
      }

    }
  }
}

/**
 * Definitions for type : LED
 **/
class LED extends Component {


// Variables for the properties of the instance
  var LED_pin_var : Byte = _

  new Port("LED", List(Led_on.getName, Led_off.getName, Led_toggle.getName), List(), this).start
  new Port("DigitalIO", List(), List(PinMode.getName, DigitalWrite.getName), this).start
  this.behavior ++= List(new LEDImplStateMachine(false, this).getBehavior)
  case class LEDImplStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
      println(this + ".onEntry")
      handler.root.getPort("DigitalIO") match{
        case Some(p) => p.send(new PinMode(LED_pin_var, PinMode_ENUM.PINMODE_OUTPUT))
        case None => println("Warning: no port DigitalIO You may consider revising your ThingML model.")
      }
    }

    override def onExit() = {
      println(this + ".onExit")
//No exit action defined for this state
    }

//create sub-states
    val LED_OFF_state = new State(LED_OFFState(), root)
    parent.addSubState(LED_OFF_state)
    case class LED_OFFState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
        handler.root.getPort("DigitalIO") match{
          case Some(p) => p.send(new DigitalWrite(LED_pin_var, DigitalState_ENUM.DIGITALSTATE_LOW))
          case None => println("Warning: no port DigitalIO You may consider revising your ThingML model.")
        }
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    val LED_ON_state = new State(LED_ONState(), root)
    parent.addSubState(LED_ON_state)
    case class LED_ONState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
        handler.root.getPort("DigitalIO") match{
          case Some(p) => p.send(new DigitalWrite(LED_pin_var, DigitalState_ENUM.DIGITALSTATE_HIGH))
          case None => println("Warning: no port DigitalIO You may consider revising your ThingML model.")
        }
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    parent.setInitial(LED_OFF_state)

//create transitions among sub-states
    val t_LED_OFF2LED_ON_1776893953 = new Transition(LED_OFF_state, LED_ON_state, TransitionLED_OFF2LED_ON_1776893953(), root)
    t_LED_OFF2LED_ON_1776893953.initEvent(Led_on.getName)
    parent.addTransition(t_LED_OFF2LED_ON_1776893953)
    val t_LED_ON2LED_OFF_271713177 = new Transition(LED_ON_state, LED_OFF_state, TransitionLED_ON2LED_OFF_271713177(), root)
    t_LED_ON2LED_OFF_271713177.initEvent(Led_off.getName)
    parent.addTransition(t_LED_ON2LED_OFF_271713177)
    case class TransitionLED_OFF2LED_ON_1776893953 extends TransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

    }
    case class TransitionLED_ON2LED_OFF_271713177 extends TransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

    }
  }
}

/**
 * Definitions for type : SoftTimer
 **/
class SoftTimer extends Component {


// Variables for the properties of the instance
  var SoftTimer_SoftTimer_target_var : Long = _

  new Port("Polling", List(Poll.getName), List(), this).start
  new Port("timer", List(Timer_start.getName, Timer_cancel.getName), List(Timer_timeout.getName), this).start
  this.behavior ++= List(new SoftTimerStateMachine(false, this).getBehavior)
  case class SoftTimerStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
      println(this + ".onEntry")
//No entry action defined for this state
    }

    override def onExit() = {
      println(this + ".onExit")
//No exit action defined for this state
    }

//create sub-states
    val Idle_state = new State(IdleState(), root)
    parent.addSubState(Idle_state)
    case class IdleState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
//No entry action defined for this state
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    val Counting_state = new State(CountingState(), root)
    parent.addSubState(Counting_state)
    val t_self_114819007 = new InternalTransition(Counting_state, new InternalTransition114819007(), root)
    t_self_114819007.initEvent(Timer_start.getName)
    Counting_state.addInternalTransition(t_self_114819007)
    case class CountingState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
//No entry action defined for this state
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    parent.setInitial(Idle_state)

//create transitions among sub-states
    val t_Idle2Counting_1838117532 = new Transition(Idle_state, Counting_state, TransitionIdle2Counting_1838117532(), root)
    t_Idle2Counting_1838117532.initEvent(Timer_start.getName)
    parent.addTransition(t_Idle2Counting_1838117532)
    val t_Counting2Idle_84419191 = new Transition(Counting_state, Idle_state, TransitionCounting2Idle_84419191(), root)
    t_Counting2Idle_84419191.initEvent(Poll.getName)
    parent.addTransition(t_Counting2Idle_84419191)
    val t_Counting2Idle_1292550819 = new Transition(Counting_state, Idle_state, TransitionCounting2Idle_1292550819(), root)
    t_Counting2Idle_1292550819.initEvent(Timer_cancel.getName)
    parent.addTransition(t_Counting2Idle_1292550819)
    case class TransitionIdle2Counting_1838117532 extends TransitionAction {
      override def checkGuard() : Boolean = {
        getEvent(Timer_start.getName).get.asInstanceOf[Timer_start].delay > 0
      }
      override def executeActions() = {
        println(this + ".executeActions")
        SoftTimer_SoftTimer_target_var = System.currentTimeMillis() + getEvent(Timer_start.getName).get.asInstanceOf[Timer_start].delay
      }

    }
    case class InternalTransition114819007 extends InternalTransitionAction {
      override def checkGuard() : Boolean = {
        getEvent(Timer_start.getName).get.asInstanceOf[Timer_start].delay > 0
      }
      override def executeActions() = {
        println(this + ".executeActions")
        SoftTimer_SoftTimer_target_var = System.currentTimeMillis() + getEvent(Timer_start.getName).get.asInstanceOf[Timer_start].delay
      }

    }
    case class TransitionCounting2Idle_84419191 extends TransitionAction {
      override def checkGuard() : Boolean = {
        !(System.currentTimeMillis() < SoftTimer_SoftTimer_target_var)
      }
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

      override def executeAfterActions() = {
        println(this + ".executeAfterActions")
        handler.root.getPort("timer") match{
          case Some(p) => p.send(new Timer_timeout())
          case None => println("Warning: no port timer You may consider revising your ThingML model.")
        }
      }

    }
    case class TransitionCounting2Idle_1292550819 extends TransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

    }
  }
}

/**
 * Definitions for type : Blink4Leds
 **/
class Blink4Leds extends Component {

  new Port("timer", List(Timer_timeout.getName), List(Timer_start.getName), this).start
  new Port("leds", List(), List(Led_toggle.getName), this).start
  this.behavior ++= List(new Blink4LedsImplStateMachine(false, this).getBehavior)
  case class Blink4LedsImplStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
      println(this + ".onEntry")
//No entry action defined for this state
    }

    override def onExit() = {
      println(this + ".onExit")
//No exit action defined for this state
    }

//create sub-states
    val Blinking_state = new State(BlinkingState(), root)
    parent.addSubState(Blinking_state)
    val t_self_1882124053 = new InternalTransition(Blinking_state, new InternalTransition1882124053(), root)
    t_self_1882124053.initEvent(Timer_timeout.getName)
    Blinking_state.addInternalTransition(t_self_1882124053)
    case class BlinkingState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
        handler.root.getPort("timer") match{
          case Some(p) => p.send(new Timer_start(500))
          case None => println("Warning: no port timer You may consider revising your ThingML model.")
        }
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    parent.setInitial(Blinking_state)

//create transitions among sub-states
    case class InternalTransition1882124053 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        handler.root.getPort("leds") match{
          case Some(p) => p.send(new Led_toggle())
          case None => println("Warning: no port leds You may consider revising your ThingML model.")
        }
        handler.root.getPort("timer") match{
          case Some(p) => p.send(new Timer_start(500))
          case None => println("Warning: no port timer You may consider revising your ThingML model.")
        }
      }

    }
  }
}