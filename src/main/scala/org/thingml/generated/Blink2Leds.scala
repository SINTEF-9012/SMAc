/**
 * File generated by the ThingML IDE
 * /!\Do not edit this file/!\
 * In case of a bug in the generated code,
 * please submit an issue on our GitHub
 **/

package org.thingml.generated
import org.sintef.smac._
import java.util.TimerTask
import java.util.Timer
import scala.util.Random
class PollTask(p : Port) extends TimerTask{
  override def run {
    p.send(new Poll())
  }
}
object Random1024{
  val r : Random = new Random()
  def randomInt() = r.nextInt(256).toByte
}// Definition of Enumeration  PinMode
object PinMode_ENUM extends Enumeration {
  type PinMode_ENUM = Byte
  val PINMODE_INPUT : Byte = 0
  val PINMODE_OUTPUT : Byte = 1
}
// Definition of Enumeration  DigitalState
object DigitalState_ENUM extends Enumeration {
  type DigitalState_ENUM = Byte
  val DIGITALSTATE_LOW : Byte = 0
  val DIGITALSTATE_HIGH : Byte = 1
}
// Definition of Enumeration  DigitalPin
object DigitalPin_ENUM extends Enumeration {
  type DigitalPin_ENUM = Byte
  val DIGITALPIN_PIN_0 : Byte = 0
  val DIGITALPIN_PIN_1 : Byte = 1
  val DIGITALPIN_PIN_2 : Byte = 2
  val DIGITALPIN_PIN_3 : Byte = 3
  val DIGITALPIN_PIN_4 : Byte = 4
  val DIGITALPIN_PIN_5 : Byte = 5
  val DIGITALPIN_PIN_6 : Byte = 6
  val DIGITALPIN_PIN_7 : Byte = 7
  val DIGITALPIN_PIN_8 : Byte = 8
  val DIGITALPIN_PIN_9 : Byte = 9
  val DIGITALPIN_PIN_10 : Byte = 10
  val DIGITALPIN_PIN_11 : Byte = 11
  val DIGITALPIN_PIN_12 : Byte = 12
  val DIGITALPIN_PIN_13 : Byte = 13
  val DIGITALPIN_A_0 : Byte = 14
  val DIGITALPIN_A_1 : Byte = 15
  val DIGITALPIN_A_2 : Byte = 16
  val DIGITALPIN_A_3 : Byte = 17
  val DIGITALPIN_A_4 : Byte = 18
  val DIGITALPIN_A_5 : Byte = 19
}
// Definition of Enumeration  PWMPin
object PWMPin_ENUM extends Enumeration {
  type PWMPin_ENUM = Byte
  val PWMPIN_PWM_PIN_3 : Byte = 3
  val PWMPIN_PWM_PIN_5 : Byte = 5
  val PWMPIN_PWM_PIN_6 : Byte = 6
  val PWMPIN_PWM_PIN_9 : Byte = 9
  val PWMPIN_PWM_PIN_10 : Byte = 10
  val PWMPIN_PWM_PIN_11 : Byte = 11
}
// Definition of Enumeration  AnalogPin
object AnalogPin_ENUM extends Enumeration {
  type AnalogPin_ENUM = Byte
  val ANALOGPIN_A_0 : Byte = 14
  val ANALOGPIN_A_1 : Byte = 15
  val ANALOGPIN_A_2 : Byte = 16
  val ANALOGPIN_A_3 : Byte = 17
  val ANALOGPIN_A_4 : Byte = 18
  val ANALOGPIN_A_5 : Byte = 19
}
// Definition of Enumeration  AnalogReference
object AnalogReference_ENUM extends Enumeration {
  type AnalogReference_ENUM = Byte
  val ANALOGREFERENCE_DEFAULT : Byte = 1
  val ANALOGREFERENCE_INTERNAL : Byte = 3
  val ANALOGREFERENCE_EXTERNAL : Byte = 0
}
// Definition of Enumeration  InterruptPin
object InterruptPin_ENUM extends Enumeration {
  type InterruptPin_ENUM = Byte
  val INTERRUPTPIN_PIN_2_INT0 : Byte = 0
  val INTERRUPTPIN_PIN_3_INT1 : Byte = 1
}
// Definition of Enumeration  InterruptTrigger
object InterruptTrigger_ENUM extends Enumeration {
  type InterruptTrigger_ENUM = Byte
  val INTERRUPTTRIGGER_CHANGE : Byte = 1
  val INTERRUPTTRIGGER_RISING : Byte = 3
  val INTERRUPTTRIGGER_FALLING : Byte = 2
  val INTERRUPTTRIGGER_LOW : Byte = 0
}
object Poll{ def getName = "poll" }
case class Poll(override val name : String = Poll.getName) extends Event(name)
object Pong{ def getName = "pong" }
case class Pong(override val name : String = Pong.getName) extends Event(name)
object Setup{ def getName = "setup" }
case class Setup(override val name : String = Setup.getName) extends Event(name)
object TestOut{ def getName = "testOut" }
case class TestOut(c : Char, override val name : String = TestOut.getName) extends Event(name)
object AnalogReadResult{ def getName = "analogReadResult" }
case class AnalogReadResult(value : Int, override val name : String = AnalogReadResult.getName) extends Event(name)
object Eeprom_sync_write{ def getName = "eeprom_sync_write" }
case class Eeprom_sync_write(address : Int, value : Short, override val name : String = Eeprom_sync_write.getName) extends Event(name)
object Eeprom_read{ def getName = "eeprom_read" }
case class Eeprom_read(address : Int, override val name : String = Eeprom_read.getName) extends Event(name)
object DetachInterrupt{ def getName = "detachInterrupt" }
case class DetachInterrupt(interrupt : Byte, override val name : String = DetachInterrupt.getName) extends Event(name)
object DigitalReadResult{ def getName = "digitalReadResult" }
case class DigitalReadResult(value : Byte, override val name : String = DigitalReadResult.getName) extends Event(name)
object Timer_start{ def getName = "timer_start" }
case class Timer_start(delay : Int, override val name : String = Timer_start.getName) extends Event(name)
object Timer_cancel{ def getName = "timer_cancel" }
case class Timer_cancel(override val name : String = Timer_cancel.getName) extends Event(name)
object Tone{ def getName = "tone" }
case class Tone(pin : Byte, frequency : Int, duration : Int, override val name : String = Tone.getName) extends Event(name)
object TestFailure{ def getName = "testFailure" }
case class TestFailure(override val name : String = TestFailure.getName) extends Event(name)
object Eeprom_value{ def getName = "eeprom_value" }
case class Eeprom_value(value : Short, override val name : String = Eeprom_value.getName) extends Event(name)
object AnalogReference{ def getName = "analogReference" }
case class AnalogReference(`type` : Byte, override val name : String = AnalogReference.getName) extends Event(name)
object AnalogRead{ def getName = "analogRead" }
case class AnalogRead(pin : Byte, override val name : String = AnalogRead.getName) extends Event(name)
object DigitalRead{ def getName = "digitalRead" }
case class DigitalRead(pin : Byte, override val name : String = DigitalRead.getName) extends Event(name)
object Led_on{ def getName = "led_on" }
case class Led_on(override val name : String = Led_on.getName) extends Event(name)
object AnalogWrite{ def getName = "analogWrite" }
case class AnalogWrite(pin : Byte, value : Short, override val name : String = AnalogWrite.getName) extends Event(name)
object NoTone{ def getName = "noTone" }
case class NoTone(pin : Byte, override val name : String = NoTone.getName) extends Event(name)
object Eeprom_write_ack{ def getName = "eeprom_write_ack" }
case class Eeprom_write_ack(override val name : String = Eeprom_write_ack.getName) extends Event(name)
object InterruptNotification{ def getName = "interruptNotification" }
case class InterruptNotification(interrupt : Byte, override val name : String = InterruptNotification.getName) extends Event(name)
object PinMode{ def getName = "pinMode" }
case class PinMode(pin : Byte, mode : Byte, override val name : String = PinMode.getName) extends Event(name)
object Ping{ def getName = "ping" }
case class Ping(override val name : String = Ping.getName) extends Event(name)
object Led_toggle{ def getName = "led_toggle" }
case class Led_toggle(override val name : String = Led_toggle.getName) extends Event(name)
object Eeprom_write{ def getName = "eeprom_write" }
case class Eeprom_write(address : Int, value : Short, override val name : String = Eeprom_write.getName) extends Event(name)
object DigitalWrite{ def getName = "digitalWrite" }
case class DigitalWrite(pin : Byte, value : Byte, override val name : String = DigitalWrite.getName) extends Event(name)
object Led_off{ def getName = "led_off" }
case class Led_off(override val name : String = Led_off.getName) extends Event(name)
object TestIn{ def getName = "testIn" }
case class TestIn(c : Char, override val name : String = TestIn.getName) extends Event(name)
object AttachInterrupt{ def getName = "attachInterrupt" }
case class AttachInterrupt(interrupt : Byte, mode : Byte, override val name : String = AttachInterrupt.getName) extends Event(name)
object Timer_timeout{ def getName = "timer_timeout" }
case class Timer_timeout(override val name : String = Timer_timeout.getName) extends Event(name)

/**
 * Definitions for type : Arduino
 **/
class Arduino extends Component {

  new Port("Polling", List(), List(Poll.getName), this).start
  new Port("DigitalIO", List(PinMode.getName, DigitalRead.getName, DigitalWrite.getName), List(DigitalReadResult.getName), this).start
  new Port("AnalogIO", List(AnalogReference.getName, AnalogRead.getName, AnalogWrite.getName), List(AnalogReadResult.getName), this).start
  new Port("AdvancedIO", List(Tone.getName, NoTone.getName), List(), this).start
  new Port("Ping", List(Ping.getName), List(Pong.getName), this).start
  new Port("Interrupts", List(AttachInterrupt.getName, DetachInterrupt.getName), List(InterruptNotification.getName), this).start
  new Port("EEPROM", List(Eeprom_read.getName, Eeprom_sync_write.getName, Eeprom_write.getName), List(Eeprom_value.getName, Eeprom_write_ack.getName), this).start
  this.behavior ++= List(new ArduinoStdlibImplStateMachine(false, this).getBehavior)
  case class ArduinoStdlibImplStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
      println(this + ".onEntry")
//No entry action defined for this state
    }

    override def onExit() = {
      println(this + ".onExit")
//No exit action defined for this state
    }

//create sub-states
    val RunningArduino_state = new State(RunningArduinoState(), root)
    parent.addSubState(RunningArduino_state)
    val t_self_462245018 = new InternalTransition(RunningArduino_state, new InternalTransition462245018(), root)
    t_self_462245018.initEvent(PinMode.getName)
    RunningArduino_state.addInternalTransition(t_self_462245018)
    val t_self_796902479 = new InternalTransition(RunningArduino_state, new InternalTransition796902479(), root)
    t_self_796902479.initEvent(DigitalWrite.getName)
    RunningArduino_state.addInternalTransition(t_self_796902479)
    val t_self_601375100 = new InternalTransition(RunningArduino_state, new InternalTransition601375100(), root)
    t_self_601375100.initEvent(DigitalRead.getName)
    RunningArduino_state.addInternalTransition(t_self_601375100)
    val t_self_2132788408 = new InternalTransition(RunningArduino_state, new InternalTransition2132788408(), root)
    t_self_2132788408.initEvent(AnalogReference.getName)
    RunningArduino_state.addInternalTransition(t_self_2132788408)
    val t_self_2071011731 = new InternalTransition(RunningArduino_state, new InternalTransition2071011731(), root)
    t_self_2071011731.initEvent(AnalogRead.getName)
    RunningArduino_state.addInternalTransition(t_self_2071011731)
    val t_self_851009394 = new InternalTransition(RunningArduino_state, new InternalTransition851009394(), root)
    t_self_851009394.initEvent(AnalogWrite.getName)
    RunningArduino_state.addInternalTransition(t_self_851009394)
    val t_self_1353096043 = new InternalTransition(RunningArduino_state, new InternalTransition1353096043(), root)
    t_self_1353096043.initEvent(Tone.getName)
    RunningArduino_state.addInternalTransition(t_self_1353096043)
    val t_self_1839972036 = new InternalTransition(RunningArduino_state, new InternalTransition1839972036(), root)
    t_self_1839972036.initEvent(NoTone.getName)
    RunningArduino_state.addInternalTransition(t_self_1839972036)
    case class RunningArduinoState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
        new Timer().scheduleAtFixedRate(new PollTask(getPort("Polling").get), 5, 5)
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    parent.setInitial(RunningArduino_state)

//create transitions among sub-states
    case class InternalTransition462245018 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        println("pinMode("+getEvent(PinMode.getName).get.asInstanceOf[PinMode].pin+", "+getEvent(PinMode.getName).get.asInstanceOf[PinMode].mode+");")
      }

    }
    case class InternalTransition796902479 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        println("digitalWrite("+getEvent(DigitalWrite.getName).get.asInstanceOf[DigitalWrite].pin+", "+getEvent(DigitalWrite.getName).get.asInstanceOf[DigitalWrite].value+");")
      }

    }
    case class InternalTransition601375100 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        handler.root.getPort("DigitalIO") match{
          case Some(p) => p.send(new DigitalReadResult(Random1024.randomInt))
          case None => println("Warning: no port DigitalIO You may consider revising your ThingML model.")
        }
      }

    }
    case class InternalTransition2132788408 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        println("analogReference("+getEvent(AnalogReference.getName).get.asInstanceOf[AnalogReference].`type`+");")
      }

    }
    case class InternalTransition2071011731 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        handler.root.getPort("AnalogIO") match{
          case Some(p) => p.send(new AnalogReadResult(Random1024.randomInt))
          case None => println("Warning: no port AnalogIO You may consider revising your ThingML model.")
        }
      }

    }
    case class InternalTransition851009394 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        println("analogWrite("+getEvent(AnalogWrite.getName).get.asInstanceOf[AnalogWrite].pin+", "+getEvent(AnalogWrite.getName).get.asInstanceOf[AnalogWrite].value+");")
      }

    }
    case class InternalTransition1353096043 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        println("tone("+getEvent(Tone.getName).get.asInstanceOf[Tone].pin+", "+getEvent(Tone.getName).get.asInstanceOf[Tone].frequency+", "+getEvent(Tone.getName).get.asInstanceOf[Tone].duration+");")
      }

    }
    case class InternalTransition1839972036 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        println("noTone("+getEvent(NoTone.getName).get.asInstanceOf[NoTone].pin+");")
      }

    }
  }
}

/**
 * Definitions for type : LED
 **/
class LED extends Component {


// Variables for the properties of the instance
  var LED_pin_var : Byte = _

  new Port("LED", List(Led_on.getName, Led_off.getName, Led_toggle.getName), List(), this).start
  new Port("DigitalIO", List(), List(PinMode.getName, DigitalWrite.getName), this).start
  this.behavior ++= List(new LEDImplStateMachine(false, this).getBehavior)
  case class LEDImplStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
      println(this + ".onEntry")
      handler.root.getPort("DigitalIO") match{
        case Some(p) => p.send(new PinMode(LED_pin_var, PinMode_ENUM.PINMODE_OUTPUT))
        case None => println("Warning: no port DigitalIO You may consider revising your ThingML model.")
      }
    }

    override def onExit() = {
      println(this + ".onExit")
//No exit action defined for this state
    }

//create sub-states
    val LED_OFF_state = new State(LED_OFFState(), root)
    parent.addSubState(LED_OFF_state)
    case class LED_OFFState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
        handler.root.getPort("DigitalIO") match{
          case Some(p) => p.send(new DigitalWrite(LED_pin_var, DigitalState_ENUM.DIGITALSTATE_LOW))
          case None => println("Warning: no port DigitalIO You may consider revising your ThingML model.")
        }
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    val LED_ON_state = new State(LED_ONState(), root)
    parent.addSubState(LED_ON_state)
    case class LED_ONState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
        handler.root.getPort("DigitalIO") match{
          case Some(p) => p.send(new DigitalWrite(LED_pin_var, DigitalState_ENUM.DIGITALSTATE_HIGH))
          case None => println("Warning: no port DigitalIO You may consider revising your ThingML model.")
        }
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    parent.setInitial(LED_OFF_state)

//create transitions among sub-states
    val t_LED_OFF2LED_ON_481131904 = new Transition(LED_OFF_state, LED_ON_state, TransitionLED_OFF2LED_ON_481131904(), root)
    t_LED_OFF2LED_ON_481131904.initEvent(Led_on.getName)
    parent.addTransition(t_LED_OFF2LED_ON_481131904)
    val t_LED_ON2LED_OFF_63374101 = new Transition(LED_ON_state, LED_OFF_state, TransitionLED_ON2LED_OFF_63374101(), root)
    t_LED_ON2LED_OFF_63374101.initEvent(Led_off.getName)
    parent.addTransition(t_LED_ON2LED_OFF_63374101)
    case class TransitionLED_OFF2LED_ON_481131904 extends TransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

    }
    case class TransitionLED_ON2LED_OFF_63374101 extends TransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

    }
  }
}

/**
 * Definitions for type : SoftTimer
 **/
class SoftTimer extends Component {


// Variables for the properties of the instance
  var SoftTimer_SoftTimer_target_var : Long = _

  new Port("Polling", List(Poll.getName), List(), this).start
  new Port("timer", List(Timer_start.getName, Timer_cancel.getName), List(Timer_timeout.getName), this).start
  this.behavior ++= List(new SoftTimerStateMachine(false, this).getBehavior)
  case class SoftTimerStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
      println(this + ".onEntry")
//No entry action defined for this state
    }

    override def onExit() = {
      println(this + ".onExit")
//No exit action defined for this state
    }

//create sub-states
    val Idle_state = new State(IdleState(), root)
    parent.addSubState(Idle_state)
    case class IdleState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
//No entry action defined for this state
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    val Counting_state = new State(CountingState(), root)
    parent.addSubState(Counting_state)
    val t_self_967050095 = new InternalTransition(Counting_state, new InternalTransition967050095(), root)
    t_self_967050095.initEvent(Timer_start.getName)
    Counting_state.addInternalTransition(t_self_967050095)
    case class CountingState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
//No entry action defined for this state
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    parent.setInitial(Idle_state)

//create transitions among sub-states
    val t_Idle2Counting_458289319 = new Transition(Idle_state, Counting_state, TransitionIdle2Counting_458289319(), root)
    t_Idle2Counting_458289319.initEvent(Timer_start.getName)
    parent.addTransition(t_Idle2Counting_458289319)
    val t_Counting2Idle_1108621139 = new Transition(Counting_state, Idle_state, TransitionCounting2Idle_1108621139(), root)
    t_Counting2Idle_1108621139.initEvent(Poll.getName)
    parent.addTransition(t_Counting2Idle_1108621139)
    val t_Counting2Idle_1182379154 = new Transition(Counting_state, Idle_state, TransitionCounting2Idle_1182379154(), root)
    t_Counting2Idle_1182379154.initEvent(Timer_cancel.getName)
    parent.addTransition(t_Counting2Idle_1182379154)
    case class TransitionIdle2Counting_458289319 extends TransitionAction {
      override def checkGuard() : Boolean = {
        getEvent(Timer_start.getName).get.asInstanceOf[Timer_start].delay > 0
      }
      override def executeActions() = {
        println(this + ".executeActions")
        SoftTimer_SoftTimer_target_var = System.currentTimeMillis() + getEvent(Timer_start.getName).get.asInstanceOf[Timer_start].delay
      }

    }
    case class InternalTransition967050095 extends InternalTransitionAction {
      override def checkGuard() : Boolean = {
        getEvent(Timer_start.getName).get.asInstanceOf[Timer_start].delay > 0
      }
      override def executeActions() = {
        println(this + ".executeActions")
        SoftTimer_SoftTimer_target_var = System.currentTimeMillis() + getEvent(Timer_start.getName).get.asInstanceOf[Timer_start].delay
      }

    }
    case class TransitionCounting2Idle_1108621139 extends TransitionAction {
      override def checkGuard() : Boolean = {
        !(System.currentTimeMillis() < SoftTimer_SoftTimer_target_var)
      }
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

      override def executeAfterActions() = {
        println(this + ".executeAfterActions")
        handler.root.getPort("timer") match{
          case Some(p) => p.send(new Timer_timeout())
          case None => println("Warning: no port timer You may consider revising your ThingML model.")
        }
      }

    }
    case class TransitionCounting2Idle_1182379154 extends TransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

    }
  }
}

/**
 * Definitions for type : Blink2Leds
 **/
class Blink2Leds extends Component {

  new Port("timer1", List(Timer_timeout.getName), List(Timer_start.getName), this).start
  new Port("timer2", List(Timer_timeout.getName), List(Timer_start.getName), this).start
  new Port("led1", List(), List(Led_toggle.getName), this).start
  new Port("led2", List(), List(Led_toggle.getName), this).start
  this.behavior ++= List(new Blink2LedsImplStateMachine(false, this).getBehavior)
  case class Blink2LedsImplStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
      println(this + ".onEntry")
//No entry action defined for this state
    }

    override def onExit() = {
      println(this + ".onExit")
//No exit action defined for this state
    }

//create sub-states
    val Blinking_state = new State(BlinkingState(), root)
    parent.addSubState(Blinking_state)
    val t_self_1883349295 = new InternalTransition(Blinking_state, new InternalTransition1883349295(), root)
    t_self_1883349295.initEvent(Timer_timeout.getName)
    Blinking_state.addInternalTransition(t_self_1883349295)
    val t_self_312759349 = new InternalTransition(Blinking_state, new InternalTransition312759349(), root)
    t_self_312759349.initEvent(Timer_timeout.getName)
    Blinking_state.addInternalTransition(t_self_312759349)
    case class BlinkingState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
        handler.root.getPort("timer1") match{
          case Some(p) => p.send(new Timer_start(1000))
          case None => println("Warning: no port timer1 You may consider revising your ThingML model.")
        }
        handler.root.getPort("timer2") match{
          case Some(p) => p.send(new Timer_start(333))
          case None => println("Warning: no port timer2 You may consider revising your ThingML model.")
        }
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    parent.setInitial(Blinking_state)

//create transitions among sub-states
    case class InternalTransition1883349295 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        handler.root.getPort("led1") match{
          case Some(p) => p.send(new Led_toggle())
          case None => println("Warning: no port led1 You may consider revising your ThingML model.")
        }
        handler.root.getPort("timer1") match{
          case Some(p) => p.send(new Timer_start(1000))
          case None => println("Warning: no port timer1 You may consider revising your ThingML model.")
        }
      }

    }
    case class InternalTransition312759349 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        handler.root.getPort("led2") match{
          case Some(p) => p.send(new Led_toggle())
          case None => println("Warning: no port led2 You may consider revising your ThingML model.")
        }
        handler.root.getPort("timer2") match{
          case Some(p) => p.send(new Timer_start(333))
          case None => println("Warning: no port timer2 You may consider revising your ThingML model.")
        }
      }

    }
  }
}