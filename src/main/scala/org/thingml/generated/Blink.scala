/**
 * File generated by the ThingML IDE
 * /!\Do not edit this file/!\
 * In case of a bug in the generated code,
 * please submit an issue on our GitHub
 **/

package org.thingml.generated
import org.sintef.smac._
// Definition of Enumeration  PinMode
object PinMode_ENUM extends Enumeration {
  type PinMode_ENUM = Byte
  val PINMODE_INPUT : Byte = 0
  val PINMODE_OUTPUT : Byte = 1
}
// Definition of Enumeration  DigitalState
object DigitalState_ENUM extends Enumeration {
  type DigitalState_ENUM = Byte
  val DIGITALSTATE_LOW : Byte = 0
  val DIGITALSTATE_HIGH : Byte = 1
}
// Definition of Enumeration  DigitalPin
object DigitalPin_ENUM extends Enumeration {
  type DigitalPin_ENUM = Byte
  val DIGITALPIN_PIN_0 : Byte = 0
  val DIGITALPIN_PIN_1 : Byte = 1
  val DIGITALPIN_PIN_2 : Byte = 2
  val DIGITALPIN_PIN_3 : Byte = 3
  val DIGITALPIN_PIN_4 : Byte = 4
  val DIGITALPIN_PIN_5 : Byte = 5
  val DIGITALPIN_PIN_6 : Byte = 6
  val DIGITALPIN_PIN_7 : Byte = 7
  val DIGITALPIN_PIN_8 : Byte = 8
  val DIGITALPIN_PIN_9 : Byte = 9
  val DIGITALPIN_PIN_10 : Byte = 10
  val DIGITALPIN_PIN_11 : Byte = 11
  val DIGITALPIN_PIN_12 : Byte = 12
  val DIGITALPIN_PIN_13 : Byte = 13
  val DIGITALPIN_A_0 : Byte = 14
  val DIGITALPIN_A_1 : Byte = 15
  val DIGITALPIN_A_2 : Byte = 16
  val DIGITALPIN_A_3 : Byte = 17
  val DIGITALPIN_A_4 : Byte = 18
  val DIGITALPIN_A_5 : Byte = 19
}
// Definition of Enumeration  PWMPin
object PWMPin_ENUM extends Enumeration {
  type PWMPin_ENUM = Byte
  val PWMPIN_PWM_PIN_3 : Byte = 3
  val PWMPIN_PWM_PIN_5 : Byte = 5
  val PWMPIN_PWM_PIN_6 : Byte = 6
  val PWMPIN_PWM_PIN_9 : Byte = 9
  val PWMPIN_PWM_PIN_10 : Byte = 10
  val PWMPIN_PWM_PIN_11 : Byte = 11
}
// Definition of Enumeration  AnalogPin
object AnalogPin_ENUM extends Enumeration {
  type AnalogPin_ENUM = Byte
  val ANALOGPIN_A_0 : Byte = 14
  val ANALOGPIN_A_1 : Byte = 15
  val ANALOGPIN_A_2 : Byte = 16
  val ANALOGPIN_A_3 : Byte = 17
  val ANALOGPIN_A_4 : Byte = 18
  val ANALOGPIN_A_5 : Byte = 19
}
// Definition of Enumeration  AnalogReference
object AnalogReference_ENUM extends Enumeration {
  type AnalogReference_ENUM = Byte
  val ANALOGREFERENCE_DEFAULT : Byte = 1
  val ANALOGREFERENCE_INTERNAL : Byte = 3
  val ANALOGREFERENCE_EXTERNAL : Byte = 0
}
// Definition of Enumeration  InterruptPin
object InterruptPin_ENUM extends Enumeration {
  type InterruptPin_ENUM = Byte
  val INTERRUPTPIN_PIN_2_INT0 : Byte = 0
  val INTERRUPTPIN_PIN_3_INT1 : Byte = 1
}
// Definition of Enumeration  InterruptTrigger
object InterruptTrigger_ENUM extends Enumeration {
  type InterruptTrigger_ENUM = Byte
  val INTERRUPTTRIGGER_CHANGE : Byte = 1
  val INTERRUPTTRIGGER_RISING : Byte = 3
  val INTERRUPTTRIGGER_FALLING : Byte = 2
  val INTERRUPTTRIGGER_LOW : Byte = 0
}
object Led_off{ def getName = "led_off" }
case class Led_off(override val name : String = Led_off.getName) extends Event(name)
object DigitalRead{ def getName = "digitalRead" }
case class DigitalRead(pin : Byte, override val name : String = DigitalRead.getName) extends Event(name)
object PinMode{ def getName = "pinMode" }
case class PinMode(pin : Byte, mode : Byte, override val name : String = PinMode.getName) extends Event(name)
object Timer_start{ def getName = "timer_start" }
case class Timer_start(delay : Int, override val name : String = Timer_start.getName) extends Event(name)
object DigitalWrite{ def getName = "digitalWrite" }
case class DigitalWrite(pin : Byte, value : Byte, override val name : String = DigitalWrite.getName) extends Event(name)
object Pong{ def getName = "pong" }
case class Pong(override val name : String = Pong.getName) extends Event(name)
object Eeprom_value{ def getName = "eeprom_value" }
case class Eeprom_value(value : Short, override val name : String = Eeprom_value.getName) extends Event(name)
object Poll{ def getName = "poll" }
case class Poll(override val name : String = Poll.getName) extends Event(name)
object TestFailure{ def getName = "testFailure" }
case class TestFailure(override val name : String = TestFailure.getName) extends Event(name)
object DetachInterrupt{ def getName = "detachInterrupt" }
case class DetachInterrupt(interrupt : Byte, override val name : String = DetachInterrupt.getName) extends Event(name)
object DigitalReadResult{ def getName = "digitalReadResult" }
case class DigitalReadResult(value : Byte, override val name : String = DigitalReadResult.getName) extends Event(name)
object Eeprom_read{ def getName = "eeprom_read" }
case class Eeprom_read(address : Int, override val name : String = Eeprom_read.getName) extends Event(name)
object AttachInterrupt{ def getName = "attachInterrupt" }
case class AttachInterrupt(interrupt : Byte, mode : Byte, override val name : String = AttachInterrupt.getName) extends Event(name)
object Eeprom_sync_write{ def getName = "eeprom_sync_write" }
case class Eeprom_sync_write(address : Int, value : Short, override val name : String = Eeprom_sync_write.getName) extends Event(name)
object Tone{ def getName = "tone" }
case class Tone(pin : Byte, frequency : Int, duration : Int, override val name : String = Tone.getName) extends Event(name)
object AnalogWrite{ def getName = "analogWrite" }
case class AnalogWrite(pin : Byte, value : Short, override val name : String = AnalogWrite.getName) extends Event(name)
object Led_toggle{ def getName = "led_toggle" }
case class Led_toggle(override val name : String = Led_toggle.getName) extends Event(name)
object Led_on{ def getName = "led_on" }
case class Led_on(override val name : String = Led_on.getName) extends Event(name)
object Setup{ def getName = "setup" }
case class Setup(override val name : String = Setup.getName) extends Event(name)
object InterruptNotification{ def getName = "interruptNotification" }
case class InterruptNotification(interrupt : Byte, override val name : String = InterruptNotification.getName) extends Event(name)
object AnalogReadResult{ def getName = "analogReadResult" }
case class AnalogReadResult(value : Int, override val name : String = AnalogReadResult.getName) extends Event(name)
object NoTone{ def getName = "noTone" }
case class NoTone(pin : Byte, override val name : String = NoTone.getName) extends Event(name)
object TestIn{ def getName = "testIn" }
case class TestIn(c : Char, override val name : String = TestIn.getName) extends Event(name)
object Timer_timeout{ def getName = "timer_timeout" }
case class Timer_timeout(override val name : String = Timer_timeout.getName) extends Event(name)
object AnalogRead{ def getName = "analogRead" }
case class AnalogRead(pin : Byte, override val name : String = AnalogRead.getName) extends Event(name)
object Eeprom_write{ def getName = "eeprom_write" }
case class Eeprom_write(address : Int, value : Short, override val name : String = Eeprom_write.getName) extends Event(name)
object Eeprom_write_ack{ def getName = "eeprom_write_ack" }
case class Eeprom_write_ack(override val name : String = Eeprom_write_ack.getName) extends Event(name)
object AnalogReference{ def getName = "analogReference" }
case class AnalogReference(`type` : Byte, override val name : String = AnalogReference.getName) extends Event(name)
object Ping{ def getName = "ping" }
case class Ping(override val name : String = Ping.getName) extends Event(name)
object TestOut{ def getName = "testOut" }
case class TestOut(c : Char, override val name : String = TestOut.getName) extends Event(name)
object Timer_cancel{ def getName = "timer_cancel" }
case class Timer_cancel(override val name : String = Timer_cancel.getName) extends Event(name)

/**
 * Definitions for type : Arduino
 **/
class Arduino extends Component {

  new Port("DigitalIO", List(PinMode.getName, DigitalRead.getName, DigitalWrite.getName), List(DigitalReadResult.getName), this).start
  new Port("AnalogIO", List(AnalogReference.getName, AnalogRead.getName, AnalogWrite.getName), List(AnalogReadResult.getName), this).start
  new Port("AdvancedIO", List(Tone.getName, NoTone.getName), List(), this).start
  new Port("Ping", List(Ping.getName), List(Pong.getName), this).start
  new Port("Interrupts", List(AttachInterrupt.getName, DetachInterrupt.getName), List(InterruptNotification.getName), this).start
  new Port("EEPROM", List(Eeprom_read.getName, Eeprom_sync_write.getName, Eeprom_write.getName), List(Eeprom_value.getName, Eeprom_write_ack.getName), this).start
  this.behavior ++= List(new ArduinoStdlibImplStateMachine(false, this).getBehavior)
  case class ArduinoStdlibImplStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
      println(this + ".onEntry")
//No entry action defined for this state
    }

    override def onExit() = {
      println(this + ".onExit")
//No exit action defined for this state
    }

//create sub-states
    val RunningArduino_state = new State(RunningArduinoState(), root)
    parent.addSubState(RunningArduino_state)
    val t_self_372984606 = new InternalTransition(RunningArduino_state, new InternalTransition372984606(), root)
    t_self_372984606.initEvent(PinMode.getName)
    RunningArduino_state.addInternalTransition(t_self_372984606)
    val t_self_471102698 = new InternalTransition(RunningArduino_state, new InternalTransition471102698(), root)
    t_self_471102698.initEvent(DigitalWrite.getName)
    RunningArduino_state.addInternalTransition(t_self_471102698)
    val t_self_1069531064 = new InternalTransition(RunningArduino_state, new InternalTransition1069531064(), root)
    t_self_1069531064.initEvent(DigitalRead.getName)
    RunningArduino_state.addInternalTransition(t_self_1069531064)
    val t_self_2027722598 = new InternalTransition(RunningArduino_state, new InternalTransition2027722598(), root)
    t_self_2027722598.initEvent(AnalogReference.getName)
    RunningArduino_state.addInternalTransition(t_self_2027722598)
    val t_self_1836265170 = new InternalTransition(RunningArduino_state, new InternalTransition1836265170(), root)
    t_self_1836265170.initEvent(AnalogRead.getName)
    RunningArduino_state.addInternalTransition(t_self_1836265170)
    val t_self_1561662062 = new InternalTransition(RunningArduino_state, new InternalTransition1561662062(), root)
    t_self_1561662062.initEvent(AnalogWrite.getName)
    RunningArduino_state.addInternalTransition(t_self_1561662062)
    val t_self_1847652919 = new InternalTransition(RunningArduino_state, new InternalTransition1847652919(), root)
    t_self_1847652919.initEvent(Tone.getName)
    RunningArduino_state.addInternalTransition(t_self_1847652919)
    val t_self_1235595167 = new InternalTransition(RunningArduino_state, new InternalTransition1235595167(), root)
    t_self_1235595167.initEvent(NoTone.getName)
    RunningArduino_state.addInternalTransition(t_self_1235595167)
    case class RunningArduinoState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
//No entry action defined for this state
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    parent.setInitial(RunningArduino_state)

//create transitions among sub-states
    case class InternalTransition372984606 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        /*println("pinMode(getEvent(PinMode.getName).get.asInstanceOf[PinMode].pin, getEvent(PinMode.getName).get.asInstanceOf[PinMode].mode");*/
      }

    }
    case class InternalTransition471102698 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        /*println("digitalWrite(getEvent(DigitalWrite.getName).get.asInstanceOf[DigitalWrite].pin, getEvent(DigitalWrite.getName).get.asInstanceOf[DigitalWrite].value");*/
      }

    }
    case class InternalTransition1069531064 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        handler.root.getPort("DigitalIO") match{
          case Some(p) => p.send(new DigitalReadResult(0))
          case None => println("Warning: no port DigitalIO You may consider revising your ThingML model.")
        }
      }

    }
    case class InternalTransition2027722598 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        /*println("analogReference(getEvent(AnalogReference.getName).get.asInstanceOf[AnalogReference].`type`");*/
      }

    }
    case class InternalTransition1836265170 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        handler.root.getPort("AnalogIO") match{
          case Some(p) => p.send(new AnalogReadResult(0))
          case None => println("Warning: no port AnalogIO You may consider revising your ThingML model.")
        }
      }

    }
    case class InternalTransition1561662062 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        /*println("analogWrite(getEvent(AnalogWrite.getName).get.asInstanceOf[AnalogWrite].pin, getEvent(AnalogWrite.getName).get.asInstanceOf[AnalogWrite].value");*/
      }

    }
    case class InternalTransition1847652919 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        /*println("tone(getEvent(Tone.getName).get.asInstanceOf[Tone].pin, getEvent(Tone.getName).get.asInstanceOf[Tone].frequency, getEvent(Tone.getName).get.asInstanceOf[Tone].duration");*/
      }

    }
    case class InternalTransition1235595167 extends InternalTransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
        /*println("noTone(getEvent(NoTone.getName).get.asInstanceOf[NoTone].pin");*/
      }

    }
  }
}

/**
 * Definitions for type : LED
 **/
class LED extends Component {


// Variables for the properties of the instance
  var LED_pin_var : Byte = _

  new Port("LED", List(Led_on.getName, Led_off.getName, Led_toggle.getName), List(), this).start
  new Port("DigitalIO", List(), List(PinMode.getName, DigitalWrite.getName), this).start
  this.behavior ++= List(new LEDImplStateMachine(false, this).getBehavior)
  case class LEDImplStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
      println(this + ".onEntry")
      handler.root.getPort("DigitalIO") match{
        case Some(p) => p.send(new PinMode(LED_pin_var, PinMode_ENUM.PINMODE_OUTPUT))
        case None => println("Warning: no port DigitalIO You may consider revising your ThingML model.")
      }
    }

    override def onExit() = {
      println(this + ".onExit")
//No exit action defined for this state
    }

//create sub-states
    val LED_OFF_state = new State(LED_OFFState(), root)
    parent.addSubState(LED_OFF_state)
    case class LED_OFFState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
        handler.root.getPort("DigitalIO") match{
          case Some(p) => p.send(new DigitalWrite(LED_pin_var, DigitalState_ENUM.DIGITALSTATE_LOW))
          case None => println("Warning: no port DigitalIO You may consider revising your ThingML model.")
        }
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    val LED_ON_state = new State(LED_ONState(), root)
    parent.addSubState(LED_ON_state)
    case class LED_ONState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
        handler.root.getPort("DigitalIO") match{
          case Some(p) => p.send(new DigitalWrite(LED_pin_var, DigitalState_ENUM.DIGITALSTATE_HIGH))
          case None => println("Warning: no port DigitalIO You may consider revising your ThingML model.")
        }
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    parent.setInitial(LED_OFF_state)

//create transitions among sub-states
    val t_LED_OFF2LED_ON_1388314661 = new Transition(LED_OFF_state, LED_ON_state, TransitionLED_OFF2LED_ON_1388314661(), root)
    t_LED_OFF2LED_ON_1388314661.initEvent(Led_on.getName)
    parent.addTransition(t_LED_OFF2LED_ON_1388314661)
    val t_LED_ON2LED_OFF_1364844884 = new Transition(LED_ON_state, LED_OFF_state, TransitionLED_ON2LED_OFF_1364844884(), root)
    t_LED_ON2LED_OFF_1364844884.initEvent(Led_off.getName)
    parent.addTransition(t_LED_ON2LED_OFF_1364844884)
    case class TransitionLED_OFF2LED_ON_1388314661 extends TransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

    }
    case class TransitionLED_ON2LED_OFF_1364844884 extends TransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

    }
  }
}

/**
 * Definitions for type : SoftTimer
 **/
class SoftTimer extends Component {


// Variables for the properties of the instance
  var SoftTimer_SoftTimer_target_var : Long = _

  new Port("Polling", List(Poll.getName), List(), this).start
  new Port("timer", List(Timer_start.getName, Timer_cancel.getName), List(Timer_timeout.getName), this).start
  this.behavior ++= List(new SoftTimerStateMachine(false, this).getBehavior)
  case class SoftTimerStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
      println(this + ".onEntry")
//No entry action defined for this state
    }

    override def onExit() = {
      println(this + ".onExit")
//No exit action defined for this state
    }

//create sub-states
    val Idle_state = new State(IdleState(), root)
    parent.addSubState(Idle_state)
    case class IdleState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
//No entry action defined for this state
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    val Counting_state = new State(CountingState(), root)
    parent.addSubState(Counting_state)
    val t_self_574937488 = new InternalTransition(Counting_state, new InternalTransition574937488(), root)
    t_self_574937488.initEvent(Timer_start.getName)
    Counting_state.addInternalTransition(t_self_574937488)
    
    case class CountingState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
//No entry action defined for this state
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    parent.setInitial(Idle_state)

//create transitions among sub-states
    val t_Idle2Counting_185012366 = new Transition(Idle_state, Counting_state, TransitionIdle2Counting_185012366(), root)
    t_Idle2Counting_185012366.initEvent(Timer_start.getName)
    parent.addTransition(t_Idle2Counting_185012366)
    val t_Counting2Idle_1384768241 = new Transition(Counting_state, Idle_state, TransitionCounting2Idle_1384768241(), root)
    t_Counting2Idle_1384768241.initEvent(Poll.getName)
    parent.addTransition(t_Counting2Idle_1384768241)
    val t_Counting2Idle_1466238202 = new Transition(Counting_state, Idle_state, TransitionCounting2Idle_1466238202(), root)
    t_Counting2Idle_1466238202.initEvent(Timer_cancel.getName)
    parent.addTransition(t_Counting2Idle_1466238202)
    case class TransitionIdle2Counting_185012366 extends TransitionAction {
      override def checkGuard() : Boolean = {
        getEvent(Timer_start.getName).get.asInstanceOf[Timer_start].delay > 0
      }
      override def executeActions() = {
        println(this + ".executeActions")
        SoftTimer_SoftTimer_target_var = System.currentTimeMillis() + getEvent(Timer_start.getName).get.asInstanceOf[Timer_start].delay
      }

    }
    case class InternalTransition574937488 extends InternalTransitionAction {
      override def checkGuard() : Boolean = {
        getEvent(Timer_start.getName).get.asInstanceOf[Timer_start].delay > 0
      }
      override def executeActions() = {
        println(this + ".executeActions")
        SoftTimer_SoftTimer_target_var = System.currentTimeMillis() + getEvent(Timer_start.getName).get.asInstanceOf[Timer_start].delay
      }

    }
    case class TransitionCounting2Idle_1384768241 extends TransitionAction {
      override def checkGuard() : Boolean = {
        //println("checkGuard")
        return !(System.currentTimeMillis() < SoftTimer_SoftTimer_target_var)
      }
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

      override def executeAfterActions() = {
        println(this + ".executeAfterActions")
        handler.root.getPort("timer") match{
          case Some(p) => p.send(new Timer_timeout())
          case None => println("Warning: no port timer You may consider revising your ThingML model.")
        }
      }

    }
    case class TransitionCounting2Idle_1466238202 extends TransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

    }
  }
}

/**
 * Definitions for type : Blink
 **/
class Blink extends Component {

  new Port("HW", List(Timer_timeout.getName), List(Led_toggle.getName, Timer_start.getName), this).start
  this.behavior ++= List(new BlinkImplStateMachine(false, this).getBehavior)
  
  case class BlinkImplStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
      println(this + ".onEntry")
//No entry action defined for this state
    }

    override def onExit() = {
      println(this + ".onExit")
//No exit action defined for this state
    }

//create sub-states
    val Blinking_state = new State(BlinkingState(), root)
    parent.addSubState(Blinking_state)
    case class BlinkingState extends StateAction {
      override def onEntry() = {
        println(this + ".onEntry")
        handler.root.getPort("HW") match{
          case Some(p) => p.send(new Timer_start(1000))
          case None => println("Warning: no port HW You may consider revising your ThingML model.")
        }
      }

      override def onExit() = {
        println(this + ".onExit")
//No exit action defined for this state
      }

    }

    parent.setInitial(Blinking_state)

//create transitions among sub-states
    val t_Blinking2Blinking_451982499 = new Transition(Blinking_state, Blinking_state, TransitionBlinking2Blinking_451982499(), root)
    t_Blinking2Blinking_451982499.initEvent(Timer_timeout.getName)
    parent.addTransition(t_Blinking2Blinking_451982499)
    case class TransitionBlinking2Blinking_451982499 extends TransitionAction {
      override def executeActions() = {
        println(this + ".executeActions")
//No action defined for this transition
      }

      override def executeAfterActions() = {
        println(this + ".executeAfterActions")
        handler.root.getPort("HW") match{
          case Some(p) => p.send(new Led_toggle())
          case None => println("Warning: no port HW You may consider revising your ThingML model.")
        }
      }

    }
  }
}