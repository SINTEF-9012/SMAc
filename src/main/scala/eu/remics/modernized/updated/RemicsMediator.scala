/**
 * File generated by the ThingML IDE
 * /!\Do not edit this file/!\
 * In case of a bug in the generated code,
 * please submit an issue on our GitHub
 **/

package eu.remics.modernized.updated
import org.sintef.smac._
import org.thingml.devices._
object Login{ def getName = "login" }
case class Login(login : String, override val name : String = Login.getName) extends Event(name)
object Log{ def getName = "log" }
case class Log(login : String, password : String, override val name : String = Log.getName) extends Event(name)
object Ack{ def getName = "ack" }
case class Ack(access : Boolean, override val name : String = Ack.getName) extends Event(name)
object Password{ def getName = "password" }
case class Password(pwd : String, override val name : String = Password.getName) extends Event(name)
object Access{ def getName = "access" }
case class Access(result : Boolean, override val name : String = Access.getName) extends Event(name)

/**
 * Definitions for type : Client
 **/
class Client(val Client_login_var : String, val Client_pwd_var : String) extends Component {

//Companion object
  object Client{
    object LoginServerPort{
      def getName = "LoginServer"
      object in {
        val ack = Ack.getName
      }
      object out {
        val log = Log.getName
      }
    }

  }

  new Port(Client.LoginServerPort.getName, List(Client.LoginServerPort.in.ack), List(Client.LoginServerPort.out.log), this).start
  this.behavior ++= List(new AuthenticationStateMachine(false, this).getBehavior)
  case class AuthenticationStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
//No entry action defined for this state
    }

    override def onExit() = {
//No exit action defined for this state
    }

//create sub-states
    val Waiting_state = new State(WaitingState(), root)
    parent.addSubState(Waiting_state)
    case class WaitingState extends StateAction {
      override def onEntry() = {
        handler.getPort("LoginServer") match{
          case Some(p) => p.send(new Log(Client_login_var, Client_pwd_var))
          case None => println("Warning: no port LoginServer You may consider revising your ThingML model.")
        }
      }

      override def onExit() = {
//No exit action defined for this state
      }

    }

    val LoggedOn_state = new State(LoggedOnState(), root)
    parent.addSubState(LoggedOn_state)
    case class LoggedOnState extends StateAction {
      override def onEntry() = {
        println( "Your are logged in")
      }

      override def onExit() = {
//No exit action defined for this state
      }

    }

    parent.setInitial(Waiting_state)

//create transitions among sub-states
    val t_Waiting2LoggedOn_1400193374 = new Transition(Waiting_state, LoggedOn_state, new TransitionWaiting2LoggedOn_1400193374(), List((Client.LoginServerPort.getName, Client.LoginServerPort.in.ack)))
    parent.addTransition(t_Waiting2LoggedOn_1400193374)
    case class TransitionWaiting2LoggedOn_1400193374 extends TransitionAction {
      override def checkGuard() : Boolean = {
        getEvent(Client.LoginServerPort.in.ack, Client.LoginServerPort.getName).get.asInstanceOf[Ack].access
      }
      override def executeActions() = {
//No action defined for this transition
      }

    }
  }
}

/**
 * Definitions for type : SubstituteServer
 **/
class SubstituteServer(var SubstituteServer_username_var : String, var SubstituteServer_password_var : String) extends Component {

//Companion object
  object SubstituteServer{
    object LoginClientPort{
      def getName = "LoginClient"
      object in {
        val login = Login.getName
        val password = Password.getName
      }
      object out {
        val access = Access.getName
      }
    }

  }

  new Port(SubstituteServer.LoginClientPort.getName, List(SubstituteServer.LoginClientPort.in.login, SubstituteServer.LoginClientPort.in.password), List(SubstituteServer.LoginClientPort.out.access), this).start
  this.behavior ++= List(new AuthenticationStateMachine(false, this).getBehavior)
  case class AuthenticationStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
//No entry action defined for this state
    }

    override def onExit() = {
//No exit action defined for this state
    }

//create sub-states
    val WaitingForLogin_state = new State(WaitingForLoginState(), root)
    parent.addSubState(WaitingForLogin_state)
    case class WaitingForLoginState extends StateAction {
      override def onEntry() = {
        println( "Ready: Waiting for credential ...")
      }

      override def onExit() = {
//No exit action defined for this state
      }

    }

    val WaitingForPassword_state = new State(WaitingForPasswordState(), root)
    parent.addSubState(WaitingForPassword_state)
    case class WaitingForPasswordState extends StateAction {
      override def onEntry() = {
//No entry action defined for this state
      }

      override def onExit() = {
//No exit action defined for this state
      }

    }

    val LoggedOn_state = new State(LoggedOnState(), root)
    parent.addSubState(LoggedOn_state)
    case class LoggedOnState extends StateAction {
      override def onEntry() = {
        println( "You are now logged in")
      }

      override def onExit() = {
//No exit action defined for this state
      }

    }

    parent.setInitial(WaitingForLogin_state)

//create transitions among sub-states
    val t_WaitingForLogin2WaitingForPassword_1379487667 = new Transition(WaitingForLogin_state, WaitingForPassword_state, new TransitionWaitingForLogin2WaitingForPassword_1379487667(), List((SubstituteServer.LoginClientPort.getName, SubstituteServer.LoginClientPort.in.login)))
    parent.addTransition(t_WaitingForLogin2WaitingForPassword_1379487667)
    val t_WaitingForPassword2LoggedOn_1961452200 = new Transition(WaitingForPassword_state, LoggedOn_state, new TransitionWaitingForPassword2LoggedOn_1961452200(), List((SubstituteServer.LoginClientPort.getName, SubstituteServer.LoginClientPort.in.password)))
    parent.addTransition(t_WaitingForPassword2LoggedOn_1961452200)
    val t_WaitingForPassword2WaitingForLogin_1446719073 = new Transition(WaitingForPassword_state, WaitingForLogin_state, new TransitionWaitingForPassword2WaitingForLogin_1446719073(), List((SubstituteServer.LoginClientPort.getName, SubstituteServer.LoginClientPort.in.password)))
    parent.addTransition(t_WaitingForPassword2WaitingForLogin_1446719073)
    case class TransitionWaitingForLogin2WaitingForPassword_1379487667 extends TransitionAction {
      override def checkGuard() : Boolean = {
        getEvent(SubstituteServer.LoginClientPort.in.login, SubstituteServer.LoginClientPort.getName).get.asInstanceOf[Login].login == SubstituteServer_username_var
      }
      override def executeActions() = {
        handler.getPort("LoginClient") match{
          case Some(p) => p.send(new Access(true))
          case None => println("Warning: no port LoginClient You may consider revising your ThingML model.")
        }
      }

    }
    case class TransitionWaitingForPassword2LoggedOn_1961452200 extends TransitionAction {
      override def checkGuard() : Boolean = {
        getEvent(SubstituteServer.LoginClientPort.in.password, SubstituteServer.LoginClientPort.getName).get.asInstanceOf[Password].pwd == SubstituteServer_password_var
      }
      override def executeActions() = {
        handler.getPort("LoginClient") match{
          case Some(p) => p.send(new Access(true))
          case None => println("Warning: no port LoginClient You may consider revising your ThingML model.")
        }
      }

    }
    case class TransitionWaitingForPassword2WaitingForLogin_1446719073 extends TransitionAction {
      override def checkGuard() : Boolean = {
        !((getEvent(SubstituteServer.LoginClientPort.in.password, SubstituteServer.LoginClientPort.getName).get.asInstanceOf[Password].pwd == SubstituteServer_password_var))
      }
      override def executeActions() = {
        handler.getPort("LoginClient") match{
          case Some(p) => p.send(new Access(false))
          case None => println("Warning: no port LoginClient You may consider revising your ThingML model.")
        }
      }

    }
  }
}

/**
 * Definitions for type : Mediator
 **/
class Mediator(var Mediator_password_var : String) extends Component {

//Companion object
  object Mediator{
    object ClientPort{
      def getName = "Client"
      object in {
        val log = Log.getName
      }
      object out {
        val ack = Ack.getName
      }
    }

    object ServerPort{
      def getName = "Server"
      object in {
        val access = Access.getName
      }
      object out {
        val login = Login.getName
        val password = Password.getName
      }
    }

  }

  new Port(Mediator.ClientPort.getName, List(Mediator.ClientPort.in.log), List(Mediator.ClientPort.out.ack), this).start
  new Port(Mediator.ServerPort.getName, List(Mediator.ServerPort.in.access), List(Mediator.ServerPort.out.login, Mediator.ServerPort.out.password), this).start
  this.behavior ++= List(new AuthenticationStateMachine(false, this).getBehavior)
  case class AuthenticationStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
    def getBehavior = parent
    val parent : StateMachine = new StateMachine(this, keepHistory, root)
    override def onEntry() = {
//No entry action defined for this state
    }

    override def onExit() = {
//No exit action defined for this state
    }

//create sub-states
    val Ready_state = new State(ReadyState(), root)
    parent.addSubState(Ready_state)
    case class ReadyState extends StateAction {
      override def onEntry() = {
        println( "Ready: Waiting for credential ...")
      }

      override def onExit() = {
//No exit action defined for this state
      }

    }

    val CheckLogin_state = new State(CheckLoginState(), root)
    parent.addSubState(CheckLogin_state)
    case class CheckLoginState extends StateAction {
      override def onEntry() = {
//No entry action defined for this state
      }

      override def onExit() = {
//No exit action defined for this state
      }

    }

    val CheckPassword_state = new State(CheckPasswordState(), root)
    parent.addSubState(CheckPassword_state)
    case class CheckPasswordState extends StateAction {
      override def onEntry() = {
        println( "Login accepted")
      }

      override def onExit() = {
//No exit action defined for this state
      }

    }

    val LoggedOn_state = new State(LoggedOnState(), root)
    parent.addSubState(LoggedOn_state)
    case class LoggedOnState extends StateAction {
      override def onEntry() = {
        println( "Password accepted")
        println( "You are now logged in")
      }

      override def onExit() = {
//No exit action defined for this state
      }

    }

    parent.setInitial(Ready_state)

//create transitions among sub-states
    val t_Ready2CheckPassword_1768078205 = new Transition(Ready_state, CheckPassword_state, new TransitionReady2CheckPassword_1768078205(), List((Mediator.ClientPort.getName, Mediator.ClientPort.in.log)))
    parent.addTransition(t_Ready2CheckPassword_1768078205)
    val t_CheckLogin2CheckPassword_553967680 = new Transition(CheckLogin_state, CheckPassword_state, new TransitionCheckLogin2CheckPassword_553967680(), List((Mediator.ServerPort.getName, Mediator.ServerPort.in.access)))
    parent.addTransition(t_CheckLogin2CheckPassword_553967680)
    val t_CheckLogin2Ready_2032086792 = new Transition(CheckLogin_state, Ready_state, new TransitionCheckLogin2Ready_2032086792(), List((Mediator.ServerPort.getName, Mediator.ServerPort.in.access)))
    parent.addTransition(t_CheckLogin2Ready_2032086792)
    val t_CheckPassword2LoggedOn_1808823678 = new Transition(CheckPassword_state, LoggedOn_state, new TransitionCheckPassword2LoggedOn_1808823678(), List((Mediator.ServerPort.getName, Mediator.ServerPort.in.access)))
    parent.addTransition(t_CheckPassword2LoggedOn_1808823678)
    val t_CheckPassword2CheckLogin_1154001966 = new Transition(CheckPassword_state, CheckLogin_state, new TransitionCheckPassword2CheckLogin_1154001966(), List((Mediator.ServerPort.getName, Mediator.ServerPort.in.access)))
    parent.addTransition(t_CheckPassword2CheckLogin_1154001966)
    case class TransitionReady2CheckPassword_1768078205 extends TransitionAction {
      override def executeActions() = {
        Mediator_password_var = getEvent(Mediator.ClientPort.in.log, Mediator.ClientPort.getName).get.asInstanceOf[Log].password
        handler.getPort("Server") match{
          case Some(p) => p.send(new Login(getEvent(Mediator.ClientPort.in.log, Mediator.ClientPort.getName).get.asInstanceOf[Log].login))
          case None => println("Warning: no port Server You may consider revising your ThingML model.")
        }
      }

    }
    case class TransitionCheckLogin2CheckPassword_553967680 extends TransitionAction {
      override def checkGuard() : Boolean = {
        getEvent(Mediator.ServerPort.in.access, Mediator.ServerPort.getName).get.asInstanceOf[Access].result
      }
      override def executeActions() = {
        handler.getPort("Server") match{
          case Some(p) => p.send(new Password(Mediator_password_var))
          case None => println("Warning: no port Server You may consider revising your ThingML model.")
        }
      }

    }
    case class TransitionCheckLogin2Ready_2032086792 extends TransitionAction {
      override def checkGuard() : Boolean = {
        !((getEvent(Mediator.ServerPort.in.access, Mediator.ServerPort.getName).get.asInstanceOf[Access].result))
      }
      override def executeActions() = {
        handler.getPort("Client") match{
          case Some(p) => p.send(new Ack(false))
          case None => println("Warning: no port Client You may consider revising your ThingML model.")
        }
      }

    }
    case class TransitionCheckPassword2LoggedOn_1808823678 extends TransitionAction {
      override def checkGuard() : Boolean = {
        getEvent(Mediator.ServerPort.in.access, Mediator.ServerPort.getName).get.asInstanceOf[Access].result
      }
      override def executeActions() = {
        handler.getPort("Client") match{
          case Some(p) => p.send(new Ack(true))
          case None => println("Warning: no port Client You may consider revising your ThingML model.")
        }
      }

    }
    case class TransitionCheckPassword2CheckLogin_1154001966 extends TransitionAction {
      override def checkGuard() : Boolean = {
        !((getEvent(Mediator.ServerPort.in.access, Mediator.ServerPort.getName).get.asInstanceOf[Access].result))
      }
      override def executeActions() = {
        handler.getPort("Client") match{
          case Some(p) => p.send(new Ack(false))
          case None => println("Warning: no port Client You may consider revising your ThingML model.")
        }
      }

    }
  }
}